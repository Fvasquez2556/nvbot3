#!/usr/bin/env python3
# scripts/integrate_feedback_system.py
"""
Script para integrar autom√°ticamente el sistema de retroalimentaci√≥n
con tu nvbot3 existente SIN modificar tu c√≥digo principal
"""

import os
import sys
from pathlib import Path

def create_integration_bridge():
    """Crea el m√≥dulo de integraci√≥n principal"""
    
    print("üåâ Creando bridge de integraci√≥n...")
    
    # Asegurar que existe el directorio integration
    integration_dir = Path("integration")
    integration_dir.mkdir(exist_ok=True)
    
    # Crear __init__.py
    init_file = integration_dir / "__init__.py"
    with open(init_file, 'w', encoding='utf-8') as f:
        f.write("# NvBot3 Integration Package\n__version__ = '1.0.0'\n")
    
    # C√≥digo completo del bridge
    bridge_code = '''"""
Puente de integraci√≥n entre nvbot3 existente y sistema de retroalimentaci√≥n
Importar este m√≥dulo en tu c√≥digo principal para activar tracking autom√°tico

EJEMPLO DE USO:
from integration.nvbot3_feedback_bridge import track_signal, update_price

# En tu funci√≥n de predicci√≥n:
if prediction['confidence'] > 0.75:
    signal_id = track_signal(symbol, prediction, current_price)

# Al recibir nuevos precios:
update_price(symbol, new_price)
"""

import sys
import os
from datetime import datetime

# CONFIGURACI√ìN DE RUTAS
current_dir = os.path.dirname(os.path.abspath(__file__))
web_dashboard_path = os.path.join(current_dir, '..', 'web_dashboard')
sys.path.append(web_dashboard_path)

# VARIABLES GLOBALES
TRACKER = None
TRACKING_ENABLED = False
DEBUG_MODE = True

def log_debug(message):
    """Log de depuraci√≥n"""
    if DEBUG_MODE:
        timestamp = datetime.now().strftime('%H:%M:%S')
        print(f"[{timestamp}] üîß NvBot3-Feedback: {message}")

def init_tracker():
    """Inicializa el tracker de forma segura"""
    global TRACKER, TRACKING_ENABLED
    
    if TRACKER is not None:
        return TRACKER  # Ya inicializado
    
    try:
        # Importar SignalTracker
        from database.signal_tracker import SignalTracker
        
        # Crear instancia
        TRACKER = SignalTracker()
        TRACKING_ENABLED = True
        
        log_debug("Sistema de tracking inicializado correctamente")
        return TRACKER
        
    except ImportError as e:
        log_debug(f"Error importando SignalTracker: {e}")
        log_debug("Verifica que web_dashboard/database/signal_tracker.py existe")
        TRACKING_ENABLED = False
        return None
        
    except Exception as e:
        log_debug(f"Error inicializando SignalTracker: {e}")
        TRACKING_ENABLED = False
        return None

def track_signal(symbol, prediction_data, current_price):
    """
    Funci√≥n principal para trackear se√±ales del nvbot3
    
    Args:
        symbol (str): S√≠mbolo de trading (ej: 'BTCUSDT')
        prediction_data (dict): Datos de predicci√≥n con claves:
            - 'type': Tipo de se√±al ('momentum_alto', 'rebound', etc.)
            - 'predicted_change': Cambio porcentual esperado
            - 'confidence': Nivel de confianza (0-1)
        current_price (float): Precio actual del activo
    
    Returns:
        str: ID de la se√±al si se guarda exitosamente, None si hay error
    
    Ejemplo de uso:
        prediction = {
            'type': 'momentum_alto',
            'predicted_change': 5.2,
            'confidence': 0.85
        }
        signal_id = track_signal('BTCUSDT', prediction, 67250.0)
    """
    
    # Inicializar tracker si es necesario
    if not TRACKING_ENABLED:
        init_tracker()
        if not TRACKING_ENABLED:
            log_debug(f"Tracking deshabilitado - no se guardar√° se√±al de {symbol}")
            return None
    
    try:
        # Validar datos de entrada
        if not symbol or not isinstance(symbol, str):
            log_debug("Error: s√≠mbolo inv√°lido")
            return None
        
        if not prediction_data or not isinstance(prediction_data, dict):
            log_debug("Error: prediction_data debe ser un diccionario")
            return None
        
        if current_price is None or current_price <= 0:
            log_debug("Error: current_price debe ser un n√∫mero positivo")
            return None
        
        # Extraer campos de predicci√≥n
        signal_type = prediction_data.get('type', 'unknown')
        predicted_change = float(prediction_data.get('predicted_change', 0))
        confidence = float(prediction_data.get('confidence', 0))
        
        # Preparar datos para el tracker
        signal_data = {
            'type': signal_type,
            'predicted_change': predicted_change,
            'confidence': confidence,
            'entry_price': current_price,
            'timestamp': datetime.now().isoformat()
        }
        
        # Guardar se√±al usando SignalTracker
        signal_id = TRACKER.save_new_signal(symbol, signal_data)
        
        if signal_id:
            log_debug(f"üìä Se√±al guardada: {symbol} | {signal_type} | Confianza: {confidence:.2f} | ID: {signal_id}")
            return signal_id
        else:
            log_debug(f"‚ö†Ô∏è No se pudo guardar se√±al para {symbol}")
            return None
            
    except Exception as e:
        log_debug(f"‚ùå Error guardando se√±al para {symbol}: {e}")
        return None

def update_price(symbol, price):
    """
    Actualiza el precio para todas las se√±ales activas de un s√≠mbolo
    Llamar esta funci√≥n cada vez que recibas un nuevo precio
    
    Args:
        symbol (str): S√≠mbolo del activo
        price (float): Precio actual
    
    Ejemplo:
        update_price('BTCUSDT', 68500.0)
    """
    
    if not TRACKING_ENABLED:
        init_tracker()
        if not TRACKING_ENABLED:
            return
    
    try:
        if not symbol or price <= 0:
            log_debug(f"Datos inv√°lidos para actualizaci√≥n de precio: {symbol}, {price}")
            return
        
        TRACKER.update_price_tracking(symbol, price)
        log_debug(f"üìà Precio actualizado: {symbol} = ${price:,.2f}")
        
    except Exception as e:
        log_debug(f"‚ùå Error actualizando precio de {symbol}: {e}")

def get_tracking_stats(days=30):
    """
    Obtiene estad√≠sticas de performance del tracking
    
    Args:
        days (int): N√∫mero de d√≠as para las estad√≠sticas
        
    Returns:
        dict: Estad√≠sticas de las se√±ales
    """
    
    if not TRACKING_ENABLED:
        init_tracker()
        if not TRACKING_ENABLED:
            return {"error": "Sistema de tracking no disponible"}
    
    try:
        stats = TRACKER.get_performance_stats(days=days)
        log_debug(f"üìä Estad√≠sticas obtenidas: {stats}")
        return stats
    except Exception as e:
        log_debug(f"‚ùå Error obteniendo estad√≠sticas: {e}")
        return {"error": str(e)}

def get_active_signals():
    """
    Obtiene todas las se√±ales actualmente siendo monitoreadas
    
    Returns:
        list: Lista de se√±ales activas
    """
    
    if not TRACKING_ENABLED:
        init_tracker()
        if not TRACKING_ENABLED:
            return []
    
    try:
        signals = TRACKER.get_active_signals()
        log_debug(f"üìã Se√±ales activas obtenidas: {len(signals)}")
        return signals
    except Exception as e:
        log_debug(f"‚ùå Error obteniendo se√±ales activas: {e}")
        return []

def save_feedback(signal_id, feedback_data):
    """
    Guarda feedback manual sobre una se√±al
    
    Args:
        signal_id (str): ID de la se√±al
        feedback_data (dict): Datos del feedback
    """
    
    if not TRACKING_ENABLED:
        init_tracker()
        if not TRACKING_ENABLED:
            return False
    
    try:
        TRACKER.save_user_feedback(signal_id, feedback_data)
        log_debug(f"üí¨ Feedback guardado para se√±al {signal_id}")
        return True
    except Exception as e:
        log_debug(f"‚ùå Error guardando feedback: {e}")
        return False

def enable_debug(enabled=True):
    """Habilita/deshabilita logs de depuraci√≥n"""
    global DEBUG_MODE
    DEBUG_MODE = enabled
    log_debug(f"Debug mode {'habilitado' if enabled else 'deshabilitado'}")

def get_system_status():
    """
    Obtiene el estado del sistema de tracking
    
    Returns:
        dict: Estado del sistema
    """
    
    status = {
        'tracking_enabled': TRACKING_ENABLED,
        'tracker_initialized': TRACKER is not None,
        'debug_mode': DEBUG_MODE,
        'python_version': sys.version,
        'timestamp': datetime.now().isoformat()
    }
    
    if TRACKING_ENABLED and TRACKER:
        try:
            # Intentar obtener estad√≠sticas b√°sicas
            stats = TRACKER.get_performance_stats(days=1)
            status['recent_signals'] = stats.get('total_signals', 0)
            status['database_accessible'] = True
        except Exception as e:
            status['database_accessible'] = False
            status['database_error'] = str(e)
    
    return status

# Aliases para compatibilidad
manual_price_update = update_price  # Alias del nombre original
get_stats = get_tracking_stats      # Alias m√°s corto

# Funci√≥n de ejemplo y demostraci√≥n
def run_integration_demo():
    """
    Ejecuta una demostraci√≥n del sistema de integraci√≥n
    √ötil para probar que todo funcione correctamente
    """
    
    print("ü§ñ DEMOSTRACI√ìN DEL SISTEMA DE INTEGRACI√ìN NVBOT3")
    print("=" * 55)
    
    # Mostrar estado del sistema
    status = get_system_status()
    print(f"üìä Estado del sistema:")
    for key, value in status.items():
        print(f"   {key}: {value}")
    
    if not TRACKING_ENABLED:
        print("\\n‚ùå Sistema de tracking no disponible")
        print("üí° Ejecuta: python scripts/fix_import_errors.py")
        return
    
    print("\\nüß™ Ejecutando pruebas de integraci√≥n...")
    
    # Datos de prueba similares a nvbot3 real
    test_scenarios = [
        {
            'symbol': 'BTCUSDT',
            'prediction': {
                'type': 'momentum_alto',
                'predicted_change': 4.8,
                'confidence': 0.87
            },
            'price': 67250.0
        },
        {
            'symbol': 'ETHUSDT',
            'prediction': {
                'type': 'rebound',
                'predicted_change': 3.2,
                'confidence': 0.73
            },
            'price': 3180.0
        }
    ]
    
    signals_created = []
    
    # Crear se√±ales de prueba
    for i, scenario in enumerate(test_scenarios):
        print(f"\\nüì° Prueba {i+1}: {scenario['symbol']}")
        
        signal_id = track_signal(
            scenario['symbol'],
            scenario['prediction'],
            scenario['price']
        )
        
        if signal_id:
            signals_created.append(signal_id)
            print(f"   ‚úÖ Se√±al creada: {signal_id}")
            
            # Simular actualizaci√≥n de precio
            new_price = scenario['price'] * 1.02  # +2%
            update_price(scenario['symbol'], new_price)
            print(f"   üìà Precio actualizado: ${new_price:,.2f}")
        else:
            print(f"   ‚ùå Error creando se√±al")
    
    # Mostrar estad√≠sticas finales
    print(f"\\nüìä RESULTADO DE LA DEMOSTRACI√ìN:")
    print(f"   Se√±ales creadas: {len(signals_created)}")
    
    if signals_created:
        stats = get_tracking_stats()
        print(f"   Estad√≠sticas: {stats}")
        
        active_signals = get_active_signals()
        print(f"   Se√±ales activas: {len(active_signals)}")
        
        print("\\nüéâ ¬°Integraci√≥n funcionando correctamente!")
        print("üí° Ahora puedes integrar estas funciones en tu c√≥digo nvbot3")
    else:
        print("\\n‚ö†Ô∏è No se pudieron crear se√±ales de prueba")
        print("üîß Verifica la configuraci√≥n del sistema")

if __name__ == "__main__":
    print("üîß NVBOT3 FEEDBACK INTEGRATION BRIDGE")
    print("Ejecutando demostraci√≥n del sistema...")
    print()
    
    run_integration_demo()
'''
    
    # Escribir el archivo bridge
    bridge_file = integration_dir / "nvbot3_feedback_bridge.py"
    with open(bridge_file, 'w', encoding='utf-8') as f:
        f.write(bridge_code)
    
    print(f"   ‚úÖ Bridge creado: {bridge_file}")
    return True

def create_startup_script():
    """Crea script de inicio del dashboard"""
    
    print("üöÄ Creando script de inicio...")
    
    # Asegurar que existe el directorio scripts
    scripts_dir = Path("scripts")
    scripts_dir.mkdir(exist_ok=True)
    
    # C√≥digo del script de inicio (ya lo tenemos en otros artifacts)
    startup_code = '''#!/usr/bin/env python3
# scripts/start_dashboard.py
"""
Script simplificado para iniciar el dashboard
Creado autom√°ticamente por integrate_feedback_system.py
"""

import sys
import os
import subprocess
from pathlib import Path

def main():
    print("üåê Iniciando NvBot3 Dashboard...")
    
    # Verificar que existe la aplicaci√≥n
    if not Path("web_dashboard/app.py").exists():
        print("‚ùå Error: No se encontr√≥ web_dashboard/app.py")
        print("üîß Ejecuta: python scripts/integrate_feedback_system.py")
        return
    
    # Cambiar al directorio del dashboard
    original_dir = os.getcwd()
    
    try:
        os.chdir("web_dashboard")
        print("üìä Iniciando servidor Flask en http://localhost:5000")
        print("‚èπÔ∏è  Presiona Ctrl+C para detener")
        
        # Ejecutar la aplicaci√≥n Flask
        subprocess.run([sys.executable, "app.py"], check=True)
        
    except KeyboardInterrupt:
        print("\\nüõë Dashboard detenido")
    except Exception as e:
        print(f"‚ùå Error: {e}")
    finally:
        os.chdir(original_dir)

if __name__ == "__main__":
    main()
'''
    
    startup_file = scripts_dir / "start_dashboard.py"
    with open(startup_file, 'w', encoding='utf-8') as f:
        f.write(startup_code)
    
    print(f"   ‚úÖ Script de inicio creado: {startup_file}")
    return True

def create_example_integration():
    """Crea ejemplo de c√≥mo integrar con nvbot3 existente"""
    
    print("üìö Creando ejemplos de integraci√≥n...")
    
    # Asegurar que existe el directorio examples
    examples_dir = Path("examples")
    examples_dir.mkdir(exist_ok=True)
    
    # C√≥digo de ejemplo completo
    example_code = '''#!/usr/bin/env python3
# examples/nvbot3_con_tracking.py
"""
EJEMPLO: C√≥mo integrar el sistema de feedback con tu nvbot3 existente

ANTES de usar este ejemplo:
1. Ejecuta: python scripts/integrate_feedback_system.py
2. Instala: pip install flask flask-socketio pandas
3. Inicia dashboard: python scripts/start_dashboard.py (en otra terminal)

DESPU√âS de integrar:
- Todas las se√±ales con buena confianza se guardar√°n autom√°ticamente
- Puedes ver las se√±ales en: http://localhost:5000
- Puedes dar feedback sobre cada predicci√≥n
- El sistema aprende de tu feedback
"""

import asyncio
import time
from datetime import datetime
import random

# PASO 1: IMPORTAR EL SISTEMA DE TRACKING
# Esta es la √öNICA l√≠nea que necesitas agregar a tu c√≥digo existente
from integration.nvbot3_feedback_bridge import track_signal, update_price

# Simulaci√≥n de tu c√≥digo nvbot3 existente
# (Reemplaza estas funciones con tu c√≥digo real)

def get_market_data(symbol):
    """
    Placeholder - reemplazar con tu funci√≥n real de obtener datos de mercado
    """
    # Simulaci√≥n de datos de mercado
    base_prices = {
        'BTCUSDT': 67250.0,
        'ETHUSDT': 3180.0,
        'ADAUSDT': 0.45
    }
    
    base_price = base_prices.get(symbol, 50000.0)
    current_price = base_price * (1 + random.uniform(-0.02, 0.02))  # ¬±2% variaci√≥n
    
    return {
        'symbol': symbol,
        'close': current_price,
        'volume': random.uniform(1000000, 5000000),
        'high': current_price * 1.01,
        'low': current_price * 0.99,
        'timestamp': datetime.now()
    }

def analyze_market_conditions(symbol, market_data):
    """
    Placeholder - reemplazar con tu an√°lisis real
    """
    # Simulaci√≥n de an√°lisis t√©cnico
    conditions = ['momentum_alto', 'rebound', 'consolidacion', 'regime']
    return {
        'trend': random.choice(['bullish', 'bearish', 'sideways']),
        'volatility': random.uniform(0.1, 0.8),
        'signal_type': random.choice(conditions),
        'strength': random.uniform(0.3, 0.9)
    }

def generate_prediction(symbol, market_data, market_conditions):
    """
    Placeholder - reemplazar con tu l√≥gica de predicci√≥n real
    """
    # Simulaci√≥n de tu sistema de predicci√≥n
    signal_types = ['momentum_alto', 'rebound', 'consolidacion']
    
    prediction = {
        'type': random.choice(signal_types),
        'predicted_change': round(random.uniform(1.5, 8.0), 2),
        'confidence': round(random.uniform(0.4, 0.95), 2),
        'timeframe': random.choice([120, 240, 360]),  # minutos
        'entry_price': market_data['close'],
        'stop_loss': market_data['close'] * 0.95,
        'take_profit': market_data['close'] * 1.05
    }
    
    return prediction

# FUNCI√ìN PRINCIPAL DE TU BOT (MODIFICADA M√çNIMAMENTE)
async def nvbot3_main_loop():
    """
    Tu loop principal de trading - MODIFICADO M√çNIMAMENTE
    Solo se agregaron 2 l√≠neas para el tracking autom√°tico
    """
    
    print("ü§ñ Iniciando NvBot3 con sistema de tracking")
    print("üìä Dashboard disponible en: http://localhost:5000")
    print("-" * 50)
    
    symbols = ['BTCUSDT', 'ETHUSDT', 'ADAUSDT']
    
    while True:
        try:
            for symbol in symbols:
                print(f"\\nüì° Analizando {symbol}...")
                
                # TU C√ìDIGO EXISTENTE - SIN CAMBIOS
                market_data = get_market_data(symbol)
                market_conditions = analyze_market_conditions(symbol, market_data)
                prediction = generate_prediction(symbol, market_data, market_conditions)
                
                print(f"   üíπ Precio: ${market_data['close']:,.2f}")
                print(f"   üéØ Predicci√≥n: {prediction['type']}")
                print(f"   üìä Confianza: {prediction['confidence']:.2f}")
                print(f"   üìà Cambio esperado: {prediction['predicted_change']:+.2f}%")
                
                # NUEVA L√çNEA 1: TRACKEAR SE√ëALES CON BUENA CONFIANZA
                # Esta es la integraci√≥n principal - solo 1 l√≠nea
                if prediction['confidence'] > 0.70:  # Threshold ajustable
                    signal_id = track_signal(symbol, prediction, market_data['close'])
                    if signal_id:
                        print(f"   üìù Se√±al trackeada: {signal_id}")
                
                # NUEVA L√çNEA 2: ACTUALIZAR PRECIO PARA TRACKING
                # Esto mantiene actualizado el sistema de tracking
                update_price(symbol, market_data['close'])
                
                # TU C√ìDIGO EXISTENTE CONTIN√öA SIN CAMBIOS
                # Aqu√≠ ir√≠an tus √≥rdenes de trading, stop losses, etc.
                
                # Simulaci√≥n de espera entre an√°lisis
                await asyncio.sleep(2)  # 2 segundos entre s√≠mbolos
            
            print("\\n‚è≥ Esperando pr√≥ximo ciclo de an√°lisis...")
            await asyncio.sleep(30)  # 30 segundos entre ciclos completos
            
        except KeyboardInterrupt:
            print("\\nüõë Bot detenido por el usuario")
            break
        except Exception as e:
            print(f"‚ùå Error en el loop principal: {e}")
            await asyncio.sleep(10)  # Esperar antes de reintentar

# FUNCI√ìN DE MONITOREO OPCIONAL
def mostrar_estadisticas_tracking():
    """
    Funci√≥n opcional para mostrar estad√≠sticas del tracking
    """
    try:
        from integration.nvbot3_feedback_bridge import get_tracking_stats, get_active_signals
        
        stats = get_tracking_stats(days=7)  # √öltimos 7 d√≠as
        active = get_active_signals()
        
        print("\\nüìä ESTAD√çSTICAS DE TRACKING:")
        print(f"   Se√±ales totales (7 d√≠as): {stats.get('total_signals', 0)}")
        print(f"   Tasa de √©xito: {stats.get('success_rate', 0):.1f}%")
        print(f"   Confianza promedio: {stats.get('average_confidence', 0):.2f}")
        print(f"   Se√±ales activas: {len(active)}")
        
    except Exception as e:
        print(f"‚ö†Ô∏è Error obteniendo estad√≠sticas: {e}")

# PUNTO DE ENTRADA PRINCIPAL
if __name__ == "__main__":
    print("üöÄ NVBOT3 CON SISTEMA DE TRACKING INTEGRADO")
    print("=" * 50)
    
    # Mostrar estad√≠sticas iniciales
    mostrar_estadisticas_tracking()
    
    print("\\nüéØ Iniciando trading autom√°tico...")
    print("üí° Tip: Abre http://localhost:5000 para ver las se√±ales en tiempo real")
    
    try:
        # Ejecutar el loop principal
        asyncio.run(nvbot3_main_loop())
    except KeyboardInterrupt:
        print("\\nüëã ¬°Bot detenido correctamente!")
    except Exception as e:
        print(f"\\n‚ùå Error fatal: {e}")
        print("üîß Verifica la configuraci√≥n del sistema")

# INSTRUCCIONES PARA INTEGRACI√ìN REAL:
"""
PARA INTEGRAR CON TU C√ìDIGO REAL:

1. IMPORTAR (al inicio de tu archivo):
   from integration.nvbot3_feedback_bridge import track_signal, update_price

2. TRACKEAR SE√ëALES (en tu funci√≥n de predicci√≥n):
   if prediction['confidence'] > 0.75:  # Threshold que prefieras
       track_signal(symbol, prediction, current_price)

3. ACTUALIZAR PRECIOS (cada vez que obtengas nuevos precios):
   update_price(symbol, new_price)

¬°Eso es todo! Solo 2-3 l√≠neas de c√≥digo adicional.

BENEFICIOS:
- Tracking autom√°tico de todas las se√±ales
- Interfaz web para ver resultados en tiempo real  
- Sistema de feedback para mejorar predicciones
- Base de datos hist√≥rica de performance
- An√°lisis estad√≠stico autom√°tico

DASHBOARD WEB:
- http://localhost:5000 - Ver se√±ales activas
- http://localhost:5000/api/test - Probar API
"""
'''
    
    example_file = examples_dir / "nvbot3_con_tracking.py"
    with open(example_file, 'w', encoding='utf-8') as f:
        f.write(example_code)
    
    print(f"   ‚úÖ Ejemplo completo creado: {example_file}")
    return True

def create_webapp_structure():
    """Crea la estructura b√°sica de la aplicaci√≥n web"""
    
    print("üåê Creando estructura de la aplicaci√≥n web...")
    
    # Crear directorios necesarios
    web_dirs = [
        "web_dashboard",
        "web_dashboard/templates",
        "web_dashboard/static/css",
        "web_dashboard/static/js",
        "web_dashboard/database"
    ]
    
    for directory in web_dirs:
        Path(directory).mkdir(parents=True, exist_ok=True)
        print(f"   ‚úÖ {directory}")
    
    # Crear archivo b√°sico de Flask si no existe
    app_file = Path("web_dashboard/app.py")
    if not app_file.exists():
        print("   ‚ö†Ô∏è web_dashboard/app.py no existe")
        print("   üí° Este archivo debe ser creado por separado con el c√≥digo Flask completo")
        
        # Crear un app.py m√≠nimo para que no falle
        minimal_app = '''# web_dashboard/app.py - VERSI√ìN M√çNIMA
# REEMPLAZAR con la versi√≥n completa del artifact

from flask import Flask
import sys
import os

app = Flask(__name__)

@app.route('/')
def dashboard():
    return """
    <h1>NvBot3 Dashboard</h1>
    <p>Sistema de retroalimentaci√≥n inicializado</p>
    <p>Reemplaza este archivo con la versi√≥n completa del app.py</p>
    """

@app.route('/api/test')
def test():
    return {"status": "Sistema funcionando", "message": "Reemplaza app.py con la versi√≥n completa"}

if __name__ == '__main__':
    print("üåê Dashboard m√≠nimo iniciado en http://localhost:5000")
    app.run(debug=True, host='0.0.0.0', port=5000)
'''
        
        with open(app_file, 'w', encoding='utf-8') as f:
            f.write(minimal_app)
        
        print(f"   ‚úÖ Archivo m√≠nimo creado: {app_file}")
    
    return True

def create_installation_summary():
    """Crea un resumen de instalaci√≥n"""
    
    summary = """# üìã RESUMEN DE INSTALACI√ìN - NVBOT3 FEEDBACK SYSTEM

## ‚úÖ ARCHIVOS CREADOS:

### üåâ Integraci√≥n:
- `integration/nvbot3_feedback_bridge.py` - Bridge principal para conectar con tu bot
- `integration/__init__.py` - Package initialization

### üöÄ Scripts:
- `scripts/start_dashboard.py` - Iniciar el dashboard web
- `scripts/integrate_feedback_system.py` - Este script de configuraci√≥n

### üìö Ejemplos:
- `examples/nvbot3_con_tracking.py` - Ejemplo completo de integraci√≥n

### üåê Estructura Web:
- `web_dashboard/` - Directorio principal de la aplicaci√≥n web
- `web_dashboard/templates/` - Templates HTML
- `web_dashboard/static/css/` - Estilos CSS  
- `web_dashboard/static/js/` - Scripts JavaScript
- `web_dashboard/database/` - Base de datos y modelos

## üìã PR√ìXIMOS PASOS:

### 1. üì¶ Instalar dependencias:
```bash
pip install flask flask-socketio pandas
```

### 2. üîß Completar archivos faltantes:
- Copia `signal_tracker.py` completo en `web_dashboard/database/`
- Copia `app.py` completo en `web_dashboard/`
- Copia `dashboard.html` completo en `web_dashboard/templates/`

### 3. üß™ Probar el sistema:
```bash
python scripts/test_feedback_system.py
```

### 4. üåê Iniciar el dashboard:
```bash  
python scripts/start_dashboard.py
```

### 5. ü§ñ Integrar con tu bot:
```python
# Al inicio de tu archivo nvbot3:
from integration.nvbot3_feedback_bridge import track_signal, update_price

# En tu funci√≥n de predicci√≥n:
if prediction['confidence'] > 0.75:
    track_signal(symbol, prediction, current_price)

# Al recibir nuevos precios:
update_price(symbol, new_price)
```

## üéØ RESULTADO ESPERADO:
- Dashboard web funcionando en http://localhost:5000
- Tracking autom√°tico de todas las se√±ales con buena confianza
- Interfaz para dar feedback sobre predicciones
- Base de datos hist√≥rica de performance
- Estad√≠sticas en tiempo real

## üîß SOLUCI√ìN DE PROBLEMAS:
- Error de imports: `python scripts/fix_import_errors.py`
- Sistema no funciona: Verificar que todos los archivos est√©n completos
- Dashboard no inicia: Revisar dependencias de Flask

¬°Sistema listo para integraci√≥n! üéâ
"""
    
    summary_file = Path("INSTALACION_COMPLETADA.md")
    with open(summary_file, 'w', encoding='utf-8') as f:
        f.write(summary)
    
    print(f"   ‚úÖ Resumen creado: {summary_file}")
    return True

def main():
    """Funci√≥n principal de integraci√≥n"""
    
    print("üîß INTEGRADOR AUTOM√ÅTICO - NVBOT3 FEEDBACK SYSTEM")
    print("=" * 60)
    
    # Verificar entorno actual
    if 'nvbot3_env' not in sys.executable:
        print("‚ö†Ô∏è Advertencia: Entorno virtual nvbot3_env no detectado")
        print("   Recomendado: nvbot3_env\\Scripts\\activate")
        print()
    
    print(f"üêç Python: {sys.version}")
    print(f"üìÇ Directorio: {os.getcwd()}")
    print()
    
    # Pasos de integraci√≥n
    integration_steps = [
        ("üåâ Creando bridge de integraci√≥n", create_integration_bridge),
        ("üöÄ Creando script de inicio", create_startup_script),
        ("üìö Creando ejemplo de integraci√≥n", create_example_integration),
        ("üåê Creando estructura web", create_webapp_structure),
        ("üìã Creando resumen de instalaci√≥n", create_installation_summary)
    ]
    
    completed_steps = 0
    total_steps = len(integration_steps)
    
    for step_name, step_function in integration_steps:
        print(f"{step_name}")
        print("-" * len(step_name))
        
        try:
            success = step_function()
            if success:
                completed_steps += 1
                print(f"   ‚úÖ Completado exitosamente\n")
            else:
                print(f"   ‚ö†Ô∏è Completado con advertencias\n")
        except Exception as e:
            print(f"   ‚ùå Error: {e}\n")
    
    # Resumen final
    print("=" * 60)
    print("üéØ RESUMEN DE INTEGRACI√ìN")
    print("=" * 60)
    
    success_rate = (completed_steps / total_steps) * 100
    print(f"‚úÖ Pasos completados: {completed_steps}/{total_steps} ({success_rate:.0f}%)")
    
    if completed_steps == total_steps:
        print("\nüéâ ¬°INTEGRACI√ìN COMPLETADA EXITOSAMENTE!")
        print("=" * 45)
        
        print("\nüìã ARCHIVOS CREADOS:")
        print("   üåâ integration/nvbot3_feedback_bridge.py")
        print("   üöÄ scripts/start_dashboard.py")  
        print("   üìö examples/nvbot3_con_tracking.py")
        print("   üìã INSTALACION_COMPLETADA.md")
        
        print("\nüìã PR√ìXIMOS PASOS OBLIGATORIOS:")
        print("   1. üì¶ Instalar dependencias: pip install flask flask-socketio pandas")
        print("   2. üìÅ Completar archivos faltantes (signal_tracker.py, app.py, etc.)")
        print("   3. üß™ Probar: python examples/nvbot3_con_tracking.py")
        print("   4. üåê Dashboard: python scripts/start_dashboard.py")
        
        print("\nü§ñ INTEGRACI√ìN CON TU BOT:")
        print("   ‚úèÔ∏è Agregar 1 l√≠nea al inicio: from integration.nvbot3_feedback_bridge import track_signal")
        print("   ‚úèÔ∏è Agregar en predicci√≥n: track_signal(symbol, prediction, price)")
        print("   ‚úÖ ¬°Tu bot tendr√° tracking autom√°tico!")
        
    else:
        print(f"\n‚ö†Ô∏è INTEGRACI√ìN PARCIALMENTE COMPLETADA ({success_rate:.0f}%)")
        print("üîß Algunos pasos tuvieron problemas, pero el sistema b√°sico est√° listo")
    
    print(f"\nüìñ Lee INSTALACION_COMPLETADA.md para instrucciones detalladas")
    print("üÜò Si hay problemas: python scripts/fix_import_errors.py")
    
    return completed_steps == total_steps

if __name__ == "__main__":
    success = main()
    
    if success:
        print("\nüöÄ ¬°Integraci√≥n lista! Procede con la instalaci√≥n de dependencias.")
    else:
        print("\n‚ö†Ô∏è Revisa los errores mostrados y vuelve a intentar.")